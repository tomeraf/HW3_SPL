Index: src/main/java/bgu/spl/net/impl/tftp/TftpClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package bgu.spl.net.impl.tftp;\r\npublic class TftpClient {\r\n    //TODO: implement the main logic of the client, when using a thread per client the main logic goes here\r\n    public static void main(String[] args) {\r\n        System.out.println(\"implement me!\");\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/bgu/spl/net/impl/tftp/TftpClient.java b/src/main/java/bgu/spl/net/impl/tftp/TftpClient.java
--- a/src/main/java/bgu/spl/net/impl/tftp/TftpClient.java	(revision c6d90530d224f9b9c701d7ccf789b04c1a5a0553)
+++ b/src/main/java/bgu/spl/net/impl/tftp/TftpClient.java	(date 1710254215396)
@@ -1,5 +1,5 @@
 package bgu.spl.net.impl.tftp;
-public class TftpClient {
+public class  TftpClient {
     //TODO: implement the main logic of the client, when using a thread per client the main logic goes here
     public static void main(String[] args) {
         System.out.println("implement me!");
Index: ../server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package bgu.spl.net.impl.rci;\r\n\r\nimport bgu.spl.net.api.MessageEncoderDecoder;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectInput;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutput;\r\nimport java.io.ObjectOutputStream;\r\nimport java.io.Serializable;\r\nimport java.nio.ByteBuffer;\r\n\r\npublic class ObjectEncoderDecoder implements MessageEncoderDecoder<Serializable> {\r\n\r\n    private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\r\n    private byte[] objectBytes = null;\r\n    private int objectBytesIndex = 0;\r\n\r\n    @Override\r\n    public void End() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public Serializable decodeNextByte(byte nextByte) {\r\n        if (objectBytes == null) { //indicates that we are still reading the length\r\n            lengthBuffer.put(nextByte);\r\n            if (!lengthBuffer.hasRemaining()) { //we read 4 bytes and therefore can take the length\r\n                lengthBuffer.flip();\r\n                objectBytes = new byte[lengthBuffer.getInt()];\r\n                objectBytesIndex = 0;\r\n                lengthBuffer.clear();\r\n            }\r\n        } else {\r\n            objectBytes[objectBytesIndex] = nextByte;\r\n            if (++objectBytesIndex == objectBytes.length) {\r\n                Serializable result = deserializeObject();\r\n                objectBytes = null;\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public byte[] encode(Serializable message) {\r\n        return serializeObject(message);\r\n    }\r\n\r\n    private Serializable deserializeObject() {\r\n        try {\r\n            ObjectInput in = new ObjectInputStream(new ByteArrayInputStream(objectBytes));\r\n            return (Serializable) in.readObject();\r\n        } catch (Exception ex) {\r\n            throw new IllegalArgumentException(\"cannot desrialize object\", ex);\r\n        }\r\n\r\n    }\r\n\r\n    private byte[] serializeObject(Serializable message) {\r\n        try {\r\n            ByteArrayOutputStream bytes = new ByteArrayOutputStream();\r\n\r\n            //placeholder for the object size\r\n            for (int i = 0; i < 4; i++) {\r\n                bytes.write(0);\r\n            }\r\n\r\n            ObjectOutput out = new ObjectOutputStream(bytes);\r\n            out.writeObj.0 ect(message);\r\n            out.flush();\r\n            byte[] result = bytes.toByteArray();\r\n\r\n            //now write the object size\r\n            ByteBuffer.wrap(result).putInt(result.length - 4);\r\n            return result;\r\n\r\n        } catch (Exception ex) {\r\n            throw new IllegalArgumentException(\"cannot serialize object\", ex);\r\n        }\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java b/../server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java
--- a/../server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java	(revision c6d90530d224f9b9c701d7ccf789b04c1a5a0553)
+++ b/../server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java	(date 1710191082196)
@@ -68,7 +68,7 @@
             }
 
             ObjectOutput out = new ObjectOutputStream(bytes);
-            out.writeObj.0 ect(message);
+            out.writeObject(message);
             out.flush();
             byte[] result = bytes.toByteArray();
 
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"aafeab24-b06d-4a20-b35f-44a3a23cfb66\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/../server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/../server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/../server/src/main/java/bgu/spl/net/impl/tftp/TftpProtocol.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/../server/src/main/java/bgu/spl/net/impl/tftp/TftpProtocol.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$/..\" />\r\n  </component>\r\n  <component name=\"MavenImportPreferences\">\r\n    <option name=\"generalSettings\">\r\n      <MavenGeneralSettings>\r\n        <option name=\"useMavenConfig\" value=\"true\" />\r\n      </MavenGeneralSettings>\r\n    </option>\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 7\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2dKFgHVwSiQxO3ORTAigeuvEAlf\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"git-widget-placeholder\": \"mor's__branch\",\r\n    \"kotlin-language-version-configured\": \"true\",\r\n    \"last_opened_file_path\": \"G:/האחסון שלי/סמסטר ג'/תכנות מערכות/עבודה 2/set_cards_game - ron hadad/HW3_SPL/client\",\r\n    \"nodejs_package_manager_path\": \"npm\",\r\n    \"vue.rearranger.settings.migration\": \"true\"\r\n  }\r\n}]]></component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"jdk-20.0.2-corretto-20.0.2.1-4caba194b151-5bc9ecd2\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"aafeab24-b06d-4a20-b35f-44a3a23cfb66\" name=\"Changes\" comment=\"\" />\r\n      <created>1709748972801</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1709748972801</updated>\r\n      <workItem from=\"1709748973812\" duration=\"179000\" />\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 989bfdd0bfdcb7d7eb33c7184429d5c980569cae)
+++ b/.idea/workspace.xml	(date 1710258792703)
@@ -6,6 +6,7 @@
   <component name="ChangeListManager">
     <list default="true" id="aafeab24-b06d-4a20-b35f-44a3a23cfb66" name="Changes" comment="">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/bgu/spl/net/impl/tftp/TftpClient.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/bgu/spl/net/impl/tftp/TftpClient.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/../server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java" beforeDir="false" afterPath="$PROJECT_DIR$/../server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/../server/src/main/java/bgu/spl/net/impl/tftp/TftpProtocol.java" beforeDir="false" afterPath="$PROJECT_DIR$/../server/src/main/java/bgu/spl/net/impl/tftp/TftpProtocol.java" afterDir="false" />
     </list>
@@ -36,7 +37,7 @@
   "keyToString": {
     "RunOnceActivity.OpenProjectViewOnStart": "true",
     "RunOnceActivity.ShowReadmeOnStart": "true",
-    "git-widget-placeholder": "mor's__branch",
+    "git-widget-placeholder": "tomer's-branch",
     "kotlin-language-version-configured": "true",
     "last_opened_file_path": "G:/האחסון שלי/סמסטר ג'/תכנות מערכות/עבודה 2/set_cards_game - ron hadad/HW3_SPL/client",
     "nodejs_package_manager_path": "npm",
Index: ../server/src/main/java/bgu/spl/net/impl/tftp/TftpProtocol.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package bgu.spl.net.impl.tftp;\r\n\r\nimport bgu.spl.net.api.BidiMessagingProtocol;\r\nimport bgu.spl.net.srv.Connections;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\nimport java.util.*;\r\n\r\nclass UsersHolder{\r\n    public static Map<Integer,Boolean> users=new HashMap<>(); ;\r\n\r\n\r\n}\r\n\r\npublic class TftpProtocol implements BidiMessagingProtocol<byte[]> {\r\n    final private String PATH = \"server/Flies/\";\r\n    private boolean shouldTerminate = false;\r\n    private int connectionId;\r\n    private Connections<byte[]> connections;\r\n    private LinkedList<byte[]> dataHolder;\r\n    private String FileName;\r\n    private Queue<byte[]> packetsToSend;\r\n    private String toSend;\r\n\r\n    @Override\r\n    public void start(int connectionId, Connections<byte[]> connections) {\r\n        this.connectionId = connectionId;\r\n        this.connections = connections;\r\n        UsersHolder.users.put(connectionId, false);\r\n    }\r\n\r\n    @Override\r\n    public void process(byte[] message) {\r\n        short opcode = (short) (((short) message[0]) << 8 | (short) (message[1]) & 0x00ff);\r\n        byte[] messageData = new byte[message.length - 2];\r\n        System.arraycopy(message, 2, messageData, 0, message.length - 2);\r\n        switch (opcode) {\r\n            case 1:\r\n                RRQ(messageData);\r\n                break;\r\n            case 2:\r\n                WRQ(messageData);\r\n                break;\r\n            case 3:\r\n                receiveDATA(messageData);\r\n                break;\r\n            case 4:\r\n                ACKReceive();\r\n                break;\r\n            //case 5: ERROR\r\n            case 6:\r\n                DIRQ(messageData);\r\n                break;\r\n            case 7:\r\n                LOGRQ(messageData);\r\n                break;\r\n            case 8:\r\n                DELRQ(messageData);\r\n                break;\r\n            //case 9: BCAST\r\n            case 10:\r\n                if (isLoggedIn()) {\r\n                    UsersHolder.users.remove(connectionId);\r\n                    shouldTerminate = true;\r\n                    SendACK();\r\n                    break;\r\n                } else {\r\n                    Error(6);\r\n                }\r\n            default:\r\n                Error(4);\r\n        }\r\n    }\r\n\r\n    private boolean isLoggedIn() {\r\n        boolean isLoggedIn = UsersHolder.users.get(connectionId);\r\n        if (!isLoggedIn) {\r\n            Error(6);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /*    error Value Meaning:\r\n                0    Not defined, see error message (if any).\r\n                1    File not found – RRQ DELRQ of non-existing file.\r\n                2    File not found – File cannot be written, read or deleted.\r\n                3    Disk full or allocation exceeded – No room in disk.\r\n                4    Illegal TFTP operation – Unknown Opcode.\r\n                5    File already exists – File name exists on WRQ.\r\n                6    User not logged in – Any opcode received before Login completes.\r\n                7    User already logged in – Login username already connected.  */\r\n\r\n    private void Error(int Error) {\r\n        String msg = \"\";\r\n        switch (Error) {\r\n            case 0:\r\n                msg = \"Error 0\";\r\n                break;\r\n            case 1:\r\n                msg = \"Error 1\";\r\n                break;\r\n            case 2:\r\n                msg = \"Error 2\";\r\n                break;\r\n            case 3:\r\n                msg = \"Error 3\";\r\n                break;\r\n            case 4:\r\n                msg = \"Error 4\";\r\n                break;\r\n            case 5:\r\n                msg = \"Error 5\";\r\n                break;\r\n            case 6:\r\n                msg = \"Error 6\";\r\n                break;\r\n            case 7:\r\n                msg = \"Error 7\";\r\n        }\r\n\r\n        byte[] BMsg = msg.getBytes();\r\n        connections.send(connectionId, BMsg);\r\n    }\r\n\r\n    private void SendACK() {\r\n        byte[] BMsg = \"ACK 0\".getBytes();\r\n        connections.send(connectionId, BMsg);\r\n    }\r\n\r\n    private void SendACK(short blockNumber) {\r\n        byte[] ACK = \"ACK\".getBytes();\r\n        byte first = (byte) (blockNumber & 0xFF); // Extracts the lower byte\r\n        byte second = (byte) ((blockNumber >> 8) & 0xFF); // Shifts and extracts the higher byte\r\n        byte[] BMsg = {0, 4, first, second};\r\n        byte[] send = new byte[ACK.length + BMsg.length];\r\n        System.arraycopy(ACK, 0, send, 0, ACK.length);\r\n        System.arraycopy(BMsg, 0, send, ACK.length, BMsg.length);\r\n        connections.send(connectionId, send);\r\n    }\r\n\r\n    private void RRQ(byte[] messageData) {\r\n        byte[] fileName = this.removeZeroFromEnd(messageData);\r\n        dataHolder = new LinkedList<>();\r\n        FileName = new String(fileName);\r\n        Path filePath = Paths.get(PATH + FileName);\r\n        if (Files.exists(filePath)) {\r\n            if (!isLoggedIn()) {\r\n                Error(6);\r\n                return;\r\n            }\r\n            SendACK();\r\n            byte[] fileContent = new byte[0];\r\n            try {\r\n                fileContent = Files.readAllBytes(filePath);\r\n            } catch (IOException e) {\r\n                Error(2);\r\n                return;\r\n            }\r\n            dataHolder.clear();\r\n            dataHolder.add(fileContent);\r\n            packetsToSend.clear();\r\n            this.prepareDATA();\r\n            ACKReceive();\r\n        } else {\r\n            Error(1);\r\n        }\r\n    }\r\n\r\n    private void WRQ(byte[] messageData) {\r\n        byte[] fileName = removeZeroFromEnd(messageData);\r\n        dataHolder = new LinkedList<>();\r\n        FileName = new String(fileName);\r\n        Path filePath = Paths.get(PATH + FileName);\r\n        if (Files.exists(filePath))\r\n            Error(5);\r\n        else {\r\n            if (!isLoggedIn()) {\r\n                Error(6);\r\n                return;\r\n            }\r\n            SendACK();\r\n        }\r\n    }\r\n\r\n    private void receiveDATA(byte[] messageData) {\r\n        short packetSize = (short) (((short) messageData[0]) << 8 | (short) (messageData[1]) & 0x00ff);\r\n        byte[] BlockNumberMessage = new byte[messageData.length - 2];\r\n        System.arraycopy(messageData, 2, BlockNumberMessage, 0, messageData.length - 2);\r\n\r\n        short blockNumber = (short) (((short) BlockNumberMessage[0]) << 8 | (short) (BlockNumberMessage[1]) & 0x00ff);\r\n        byte[] data = new byte[BlockNumberMessage.length - 2];\r\n        System.arraycopy(BlockNumberMessage, 2, data, 0, BlockNumberMessage.length - 2);\r\n\r\n        dataHolder.addLast(data);\r\n        SendACK(blockNumber);\r\n\r\n        if (packetSize < 512) {\r\n            //create file\r\n            byte[] theFile = new byte[(blockNumber - 1) * 512 + packetSize];\r\n            int i = 0;\r\n            for (byte[] arrays : dataHolder) {\r\n                System.arraycopy(arrays, 0, theFile, i * 512, arrays.length);\r\n                i++;\r\n            }\r\n            Path path = Paths.get(PATH + FileName);\r\n            try {\r\n\r\n                Path filePath = Paths.get(PATH + FileName);\r\n                if (Files.exists(filePath))\r\n                    Error(5);\r\n                else {\r\n                    Files.write(path, theFile);\r\n                    String msg = \"WRQ \" + FileName + \" complete\";\r\n                    byte[] send = msg.getBytes();\r\n                    connections.send(connectionId, send);\r\n                    this.BCAST((byte) 1, FileName.getBytes());\r\n                }\r\n            } catch (IOException e) {\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    private void prepareDATA() {\r\n        int sizeOfDataToSend = 0;\r\n        for (byte[] b : dataHolder) {\r\n            sizeOfDataToSend += b.length;\r\n        }\r\n        Byte[] theFileToSend = new Byte[sizeOfDataToSend];\r\n        int placeHere = 0;\r\n        for (byte[] arrays : dataHolder) {\r\n            System.arraycopy(arrays, 0, theFileToSend, placeHere, arrays.length);\r\n            placeHere += arrays.length;\r\n        }\r\n        boolean stop = false;\r\n        short packetNumber = 1;\r\n        int currentPacketSize = Math.min(sizeOfDataToSend + 6, 512 + 6);\r\n        while (!stop) {\r\n            byte[] packet = new byte[currentPacketSize];\r\n            packet[0] = (byte) 0;\r\n            packet[1] = (byte) 3;\r\n            short dataSegmentSize = (short) (currentPacketSize - 6);\r\n            byte[] dataSegmentSizeInBytes = {(byte) (dataSegmentSize >> 8), (byte) (dataSegmentSize & 0xff)};\r\n            packet[2] = dataSegmentSizeInBytes[0];\r\n            packet[3] = dataSegmentSizeInBytes[1];\r\n            byte[] packetNumberInBytes = {(byte) (packetNumber >> 8), (byte) (packetNumber & 0xff)};\r\n            packet[4] = packetNumberInBytes[0];\r\n            packet[5] = packetNumberInBytes[1];\r\n            System.arraycopy(theFileToSend, (packetNumber - 1) * 512, packet, 6, currentPacketSize - 6);\r\n            packetsToSend.add(packet);\r\n            packetNumber++;\r\n            if (sizeOfDataToSend < 512) {\r\n                stop = true;\r\n            } else {\r\n                Byte[] newFile = new Byte[theFileToSend.length - 512];\r\n                System.arraycopy(theFileToSend, 512, newFile, 0, newFile.length);\r\n                theFileToSend = newFile;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void DIRQ(byte[] messageData) {\r\n        if (!isLoggedIn()) {\r\n            Error(5);\r\n            return;\r\n        }\r\n        toSend = \"DIRQ complete\";\r\n        dataHolder = new LinkedList<>();\r\n        String fileName = \"\";\r\n        File directory = new File(PATH);\r\n        File[] files = directory.listFiles();\r\n        byte[] zero = new byte[1];\r\n        zero[0] = (byte) 0;\r\n        for (File file : files) {\r\n            if (file.isFile()) {\r\n                fileName = file.getName();\r\n                dataHolder.addLast(fileName.getBytes());\r\n                dataHolder.addLast(zero);\r\n            }\r\n        }\r\n        dataHolder.removeLast();\r\n        packetsToSend.clear();\r\n        this.prepareDATA();\r\n        this.ACKReceive();\r\n    }\r\n\r\n    private void ACKReceive() {\r\n        if (!packetsToSend.isEmpty())\r\n            connections.send(connectionId, packetsToSend.remove());\r\n        else {\r\n            connections.send(connectionId, toSend.getBytes());\r\n\r\n        }\r\n    }\r\n\r\n    private void LOGRQ(byte[] messageData) {\r\n        if (isLoggedIn()) {\r\n            Error(7);\r\n            return;\r\n        }\r\n\r\n        UsersHolder.users.put(connectionId, true);\r\n        SendACK();\r\n    }\r\n\r\n    private void DELRQ(byte[] messageData) {\r\n        byte[] fileName = removeZeroFromEnd(messageData);\r\n        dataHolder = new LinkedList<>();\r\n        FileName = new String(fileName);\r\n        Path filePath = Paths.get(PATH + FileName);\r\n        if (Files.exists(filePath)) {\r\n            if (!isLoggedIn()) {\r\n                Error(5);\r\n                return;\r\n            }\r\n            try {\r\n                Files.delete(filePath);\r\n                this.SendACK();\r\n                this.BCAST((byte) 0, fileName);\r\n            } catch (IOException e) {\r\n            }\r\n        } else {\r\n            Error(1);\r\n        }\r\n    }\r\n\r\n    private void BCAST(byte addedOrDeleted, byte[] filename) {\r\n        byte[] packet = new byte[4 + filename.length];\r\n        packet[0] = (byte) 0;\r\n        packet[1] = (byte) 9;\r\n        packet[2] = addedOrDeleted;\r\n        System.arraycopy(filename, 0, packet, 3, filename.length);\r\n        packet[packet.length - 1] = (byte) 0;\r\n        for (int connectionID : UsersHolder.users.keySet()) {\r\n            if (UsersHolder.users.get(connectionID)) {\r\n                connections.send(connectionID, packet);\r\n            }\r\n        }\r\n    }\r\n\r\n    public boolean shouldTerminate() {\r\n        return shouldTerminate;\r\n    }\r\n\r\n    private byte[] removeZeroFromEnd(byte[] messageData) {\r\n        byte[] fileName = new byte[messageData.length - 1];\r\n        for (int i = 0; i < messageData.length - 1; i++) {\r\n            fileName[i] = messageData[i];\r\n        }\r\n        return fileName;\r\n\r\n\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../server/src/main/java/bgu/spl/net/impl/tftp/TftpProtocol.java b/../server/src/main/java/bgu/spl/net/impl/tftp/TftpProtocol.java
--- a/../server/src/main/java/bgu/spl/net/impl/tftp/TftpProtocol.java	(revision 989bfdd0bfdcb7d7eb33c7184429d5c980569cae)
+++ b/../server/src/main/java/bgu/spl/net/impl/tftp/TftpProtocol.java	(date 1710258792216)
@@ -32,7 +32,6 @@
         this.connections = connections;
         UsersHolder.users.put(connectionId, false);
     }
-
     @Override
     public void process(byte[] message) {
         short opcode = (short) (((short) message[0]) << 8 | (short) (message[1]) & 0x00ff);
@@ -221,11 +220,8 @@
                     this.BCAST((byte) 1, FileName.getBytes());
                 }
             } catch (IOException e) {
-
             }
-
         }
-
     }
 
     private void prepareDATA() {
